/*! For license information please see 33850.eac31dd8.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkn2_compile=self.webpackChunkn2_compile||[]).push([[33850],{33850:(e,t,n)=>{n.d(t,{Z5:()=>Ee,HY:()=>Vt,mv:()=>dn,AA:()=>ze,yM:()=>Ke,xE:()=>Et,K3:()=>Ae,h:()=>Ue,GH:()=>Wt,wj:()=>Sn});const s=!1,$=!0,o=!1,l=!0,a=!0,r=!0,i=!0,c=!0,d=!0,m=!0,f=!0,h=!0,u=!0,p=!0,g=!0,y=!1,v=!0,b=!0,w=!0,N=!0,x=!0,S=!0,k=!0,R=!0,C=!0,T=!0,L=!0,E=!0,A=!0,j=!0,M=!0,O=!0,I=!0,P=!0,H=!0,B=!0,D=!0,U=!0,_=!0,z=!0,q=!0,W=!0,V=!0,F=!0,J=!1,X=!1,Y=!1,G=!1,K=!1,Z=!1,Q=!1,ee=!1,te=!1,ne=!0,se=!1,$e=!0,oe=!1,le=!0,ae=!0,re=!0,ie=!1,ce=!0,de=!0,me=!0,fe=!1,he=!1,ue=!1,pe=!0,ge="app";let ye,ve,be,we,Ne=0,xe=!1,Se=!1,ke=!1,Re=!1,Ce=null,Te=0,Le=!1;const Ee={isDev:!!Y,isBrowser:!0,isServer:!1,isTesting:!!G},Ae=e=>{const t=new URL(e,mn.$resourcesUrl$);return t.origin!==rn.location.origin?t.href:t.pathname},je=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if(te&&performance.mark){const n=`st:${e}:${t}:${Ne++}`;return performance.mark(n),()=>performance.measure(`[Stencil] ${e}() <${t}>`,n)}return()=>{}},Me="s-id",Oe="sty-id",Ie="c-id",Pe="http://www.w3.org/1999/xlink",He={},Be=e=>"object"===(e=typeof e)||"function"===e;function De(e){var t,n,s;return null!==(s=null===(n=null===(t=e.head)||void 0===t?void 0:t.querySelector('meta[name="csp-nonce"]'))||void 0===n?void 0:n.getAttribute("content"))&&void 0!==s?s:void 0}const Ue=function(e,t){let n=null,s=null,$=null,o=!1,l=!1;const a=[],r=t=>{for(let s=0;s<t.length;s++)n=t[s],Array.isArray(n)?r(n):null!=n&&"boolean"!==typeof n&&((o="function"!==typeof e&&!Be(n))?n=String(n):Y&&"function"!==typeof e&&void 0===n.$flags$&&nn("vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects."),o&&l?a[a.length-1].$text$+=n:a.push(o?_e(null,n):n),l=o)};for(var i=arguments.length,c=new Array(i>2?i-2:0),d=2;d<i;d++)c[d-2]=arguments[d];if(r(c),t&&(Y&&"input"===e&&Je(t),B&&t.key&&(s=t.key),ne&&t.name&&($=t.name),P)){const e=t.className||t.class;e&&(t.class="object"!==typeof e?e:Object.keys(e).filter((t=>e[t])).join(" "))}if(Y&&a.some(qe)&&nn("The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function."),H&&"function"===typeof e)return e(null===t?{}:t,a,We);const m=_e(e,null);return m.$attrs$=t,a.length>0&&(m.$children$=a),B&&(m.$key$=s),ne&&(m.$name$=$),m},_e=(e,t)=>{const n={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return O&&(n.$attrs$=null),B&&(n.$key$=null),ne&&(n.$name$=null),n},ze={},qe=e=>e&&e.$tag$===ze,We={forEach:(e,t)=>e.map(Ve).forEach(t),map:(e,t)=>e.map(Ve).map(t).map(Fe)},Ve=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Fe=e=>{if("function"===typeof e.vtag){const t=Object.assign({},e.vattrs);return e.vkey&&(t.key=e.vkey),e.vname&&(t.name=e.vname),Ue(e.vtag,t,...e.vchildren||[])}const t=_e(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Je=e=>{const t=Object.keys(e),n=t.indexOf("value");if(-1===n)return;const s=t.indexOf("type"),$=t.indexOf("min"),o=t.indexOf("max"),l=t.indexOf("step");(n<s||n<$||n<o||n<l)&&sn('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},Xe=(e,t,n,s,$,o,l)=>{let a,r,i,c;if(1===o.nodeType){for(a=o.getAttribute(Ie),a&&(r=a.split("."),r[0]!==l&&"0"!==r[0]||(i={$flags$:0,$hostId$:r[0],$nodeId$:r[1],$depth$:r[2],$index$:r[3],$tag$:o.tagName.toLowerCase(),$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push(i),o.removeAttribute(Ie),e.$children$||(e.$children$=[]),e.$children$[i.$index$]=i,e=i,s&&"0"===i.$depth$&&(s[i.$index$]=i.$elm$))),c=o.childNodes.length-1;c>=0;c--)Xe(e,t,n,s,$,o.childNodes[c],l);if(o.shadowRoot)for(c=o.shadowRoot.childNodes.length-1;c>=0;c--)Xe(e,t,n,s,$,o.shadowRoot.childNodes[c],l)}else if(8===o.nodeType)r=o.nodeValue.split("."),r[1]!==l&&"0"!==r[1]||(a=r[0],i={$flags$:0,$hostId$:r[1],$nodeId$:r[2],$depth$:r[3],$index$:r[4],$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},"t"===a?(i.$elm$=o.nextSibling,i.$elm$&&3===i.$elm$.nodeType&&(i.$text$=i.$elm$.textContent,t.push(i),o.remove(),e.$children$||(e.$children$=[]),e.$children$[i.$index$]=i,s&&"0"===i.$depth$&&(s[i.$index$]=i.$elm$))):i.$hostId$===l&&("s"===a?(i.$tag$="slot",r[5]?o["s-sn"]=i.$name$=r[5]:o["s-sn"]="",o["s-sr"]=!0,C&&s&&(i.$elm$=cn.createElement(i.$tag$),i.$name$&&i.$elm$.setAttribute("name",i.$name$),o.parentNode.insertBefore(i.$elm$,o),o.remove(),"0"===i.$depth$&&(s[i.$index$]=i.$elm$)),n.push(i),e.$children$||(e.$children$=[]),e.$children$[i.$index$]=i):"r"===a&&(C&&s?o.remove():ne&&($["s-cr"]=o,o["s-cn"]=!0))));else if(e&&"style"===e.$tag$){const t=_e(null,o.textContent);t.$elm$=o,t.$index$="0",e.$children$=[t]}},Ye=(e,t)=>{if(1===e.nodeType){let n=0;for(;n<e.childNodes.length;n++)Ye(e.childNodes[n],t);if(e.shadowRoot)for(n=0;n<e.shadowRoot.childNodes.length;n++)Ye(e.shadowRoot.childNodes[n],t)}else if(8===e.nodeType){const n=e.nodeValue.split(".");"o"===n[0]&&(t.set(n[1]+"."+n[2],e),e.nodeValue="",e["s-en"]=n[3])}},Ge=e=>an.map((t=>t(e))).find((e=>!!e)),Ke=(e,t,n)=>{const s=(e=>ee?Kt(e).$hostElement$:e)(e);return{emit:e=>(Y&&!s.isConnected&&sn(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),Ze(s,t,{bubbles:!!(4&n),composed:!!(2&n),cancelable:!!(1&n),detail:e}))}},Ze=(e,t,n)=>{const s=mn.ce(t,n);return e.dispatchEvent(s),s},Qe=new WeakMap,et=(e,t,n)=>{let s=ln.get(e);un&&n?(s=s||new CSSStyleSheet,"string"===typeof s?s=t:s.replaceSync(t)):s=t,ln.set(e,s)},tt=(e,t,n,s)=>{var $;let o=st(t,n);const l=ln.get(o);if(!pe)return o;if(e=11===e.nodeType?e:cn,l)if("string"===typeof l){e=e.head||e;let n,a=Qe.get(e);if(a||Qe.set(e,a=new Set),!a.has(o)){if(Z&&e.host&&(n=e.querySelector(`[${Oe}="${o}"]`)))n.innerHTML=l;else{if(ie&&mn.$cssShim$){n=mn.$cssShim$.createHostStyle(s,o,l,!!(10&t.$flags$));const e=n["s-sc"];e&&(o=e,a=null)}else n=cn.createElement("style"),n.innerHTML=l;const r=null!==($=mn.$nonce$)&&void 0!==$?$:De(cn);null!=r&&n.setAttribute("nonce",r),(K||J)&&n.setAttribute(Oe,o),e.insertBefore(n,e.querySelector("link"))}a&&a.add(o)}}else ce&&!e.adoptedStyleSheets.includes(l)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return o},nt=e=>{const t=e.$cmpMeta$,n=e.$hostElement$,s=t.$flags$,$=je("attachStyles",t.$tagName$),o=tt(C&&fn&&n.shadowRoot?n.shadowRoot:n.getRootNode(),t,e.$modeName$,n);(C||R)&&L&&10&s&&(n["s-sc"]=o,n.classList.add(o+"-h"),R&&2&s&&n.classList.add(o+"-s")),$()},st=(e,t)=>"sc-"+(N&&t&&32&e.$flags$?e.$tagName$+"-"+t:e.$tagName$),$t=(e,t,n,s,$,o)=>{if(n!==s){let a=Qt(e,t),r=t.toLowerCase();if(P&&"class"===t){const t=e.classList,$=lt(n),o=lt(s);t.remove(...$.filter((e=>e&&!o.includes(e)))),t.add(...o.filter((e=>e&&!$.includes(e))))}else if(q&&"style"===t){if(M)for(const t in n)s&&null!=s[t]||(!K&&t.includes("-")?e.style.removeProperty(t):e.style[t]="");for(const t in s)n&&s[t]===n[t]||(!K&&t.includes("-")?e.style.setProperty(t,s[t]):e.style[t]=s[t])}else if(B&&"key"===t);else if(U&&"ref"===t)s&&s(e);else if(!D||(ee?a:e.__lookupSetter__(t))||"o"!==t[0]||"n"!==t[1]){if(_){const i=Be(s);if((a||i&&null!==s)&&!$)try{if(e.tagName.includes("-"))e[t]=s;else{const $=null==s?"":s;"list"===t?a=!1:null!=n&&e[t]==$||(e[t]=$)}}catch(l){}let c=!1;I&&r!==(r=r.replace(/^xlink\:?/,""))&&(t=r,c=!0),null==s||!1===s?!1===s&&""!==e.getAttribute(t)||(I&&c?e.removeAttributeNS(Pe,t):e.removeAttribute(t)):(!a||4&o||$)&&!i&&(s=!0===s?"":s,I&&c?e.setAttributeNS(Pe,t,s):e.setAttribute(t,s))}}else t="-"===t[2]?t.slice(3):Qt(rn,r)?r.slice(2):r[2]+t.slice(3),n&&mn.rel(e,t,n,!1),s&&mn.ael(e,t,s,!1)}},ot=/\s/,lt=e=>e?e.split(ot):[],at=(e,t,n,s)=>{const $=11===t.$elm$.nodeType&&t.$elm$.host?t.$elm$.host:t.$elm$,o=e&&e.$attrs$||He,l=t.$attrs$||He;if(M)for(s in o)s in l||$t($,s,o[s],void 0,n,t.$flags$);for(s in l)$t($,s,o[s],l[s],n,t.$flags$)},rt=(e,t,n,s)=>{const $=t.$children$[n];let o,l,a,r=0;if(ne&&!xe&&(ke=!0,"slot"===$.$tag$&&(ye&&s.classList.add(ye+"-s"),$.$flags$|=$.$children$?2:1)),Y&&$.$elm$&&nn(`The JSX ${null!==$.$text$?`"${$.$text$}" text`:`"${$.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),W&&null!==$.$text$)o=$.$elm$=cn.createTextNode($.$text$);else if(ne&&1&$.$flags$)o=$.$elm$=X||K?Nt($):cn.createTextNode("");else{if(j&&!Re&&(Re="svg"===$.$tag$),o=$.$elm$=j?cn.createElementNS(Re?"http://www.w3.org/2000/svg":"http://www.w3.org/1999/xhtml",ne&&2&$.$flags$?"slot-fb":$.$tag$):cn.createElement(ne&&2&$.$flags$?"slot-fb":$.$tag$),j&&Re&&"foreignObject"===$.$tag$&&(Re=!1),O&&at(null,$,Re),(C||R)&&null!=ye&&o["s-si"]!==ye&&o.classList.add(o["s-si"]=ye),$.$children$)for(r=0;r<$.$children$.length;++r)l=rt(e,$,r,o),l&&o.appendChild(l);j&&("svg"===$.$tag$?Re=!1:"foreignObject"===o.tagName&&(Re=!0))}return ne&&(o["s-hn"]=be,3&$.$flags$&&(o["s-sr"]=!0,o["s-cr"]=ve,o["s-sn"]=$.$name$||"",a=e&&e.$children$&&e.$children$[n],a&&a.$tag$===$.$tag$&&e.$elm$&&it(e.$elm$,!1))),o},it=(e,t)=>{mn.$flags$|=1;const n=e.childNodes;for(let s=n.length-1;s>=0;s--){const e=n[s];e["s-hn"]!==be&&e["s-ol"]&&(ht(e).insertBefore(e,ft(e)),e["s-ol"].remove(),e["s-ol"]=void 0,ke=!0),t&&it(e,t)}mn.$flags$&=-2},ct=(e,t,n,s,$,o)=>{let l,a=ne&&e["s-cr"]&&e["s-cr"].parentNode||e;for(C&&a.shadowRoot&&a.tagName===be&&(a=a.shadowRoot);$<=o;++$)s[$]&&(l=rt(null,n,$,e),l&&(s[$].$elm$=l,a.insertBefore(l,ne?ft(t):t)))},dt=(e,t,n,s,$)=>{for(;t<=n;++t)(s=e[t])&&($=s.$elm$,bt(s),ne&&(Se=!0,$["s-ol"]?$["s-ol"].remove():it($,!0)),$.remove())},mt=(e,t)=>e.$tag$===t.$tag$&&(ne&&"slot"===e.$tag$?e.$name$===t.$name$:!B||e.$key$===t.$key$),ft=e=>e&&e["s-ol"]||e,ht=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,ut=(e,t)=>{const n=t.$elm$=e.$elm$,s=e.$children$,$=t.$children$,o=t.$tag$,l=t.$text$;let a;W&&null!==l?W&&ne&&(a=n["s-cr"])?a.parentNode.textContent=l:W&&e.$text$!==l&&(n.data=l):(j&&(Re="svg"===o||"foreignObject"!==o&&Re),(O||k)&&(T&&"slot"===o||at(e,t,Re)),M&&null!==s&&null!==$?((e,t,n,s)=>{let $,o,l=0,a=0,r=0,i=0,c=t.length-1,d=t[0],m=t[c],f=s.length-1,h=s[0],u=s[f];for(;l<=c&&a<=f;)if(null==d)d=t[++l];else if(null==m)m=t[--c];else if(null==h)h=s[++a];else if(null==u)u=s[--f];else if(mt(d,h))ut(d,h),d=t[++l],h=s[++a];else if(mt(m,u))ut(m,u),m=t[--c],u=s[--f];else if(mt(d,u))!ne||"slot"!==d.$tag$&&"slot"!==u.$tag$||it(d.$elm$.parentNode,!1),ut(d,u),e.insertBefore(d.$elm$,m.$elm$.nextSibling),d=t[++l],u=s[--f];else if(mt(m,h))!ne||"slot"!==d.$tag$&&"slot"!==u.$tag$||it(m.$elm$.parentNode,!1),ut(m,h),e.insertBefore(m.$elm$,d.$elm$),m=t[--c],h=s[++a];else{if(r=-1,B)for(i=l;i<=c;++i)if(t[i]&&null!==t[i].$key$&&t[i].$key$===h.$key$){r=i;break}B&&r>=0?(o=t[r],o.$tag$!==h.$tag$?$=rt(t&&t[a],n,r,e):(ut(o,h),t[r]=void 0,$=o.$elm$),h=s[++a]):($=rt(t&&t[a],n,a,e),h=s[++a]),$&&(ne?ht(d.$elm$).insertBefore($,ft(d.$elm$)):d.$elm$.parentNode.insertBefore($,d.$elm$))}l>c?ct(e,null==s[f+1]?null:s[f+1].$elm$,n,s,a,f):M&&a>f&&dt(t,l,c)})(n,s,t,$):null!==$?(M&&W&&null!==e.$text$&&(n.textContent=""),ct(n,null,t,$,0,$.length-1)):M&&null!==s&&dt(s,0,s.length-1),j&&Re&&"svg"===o&&(Re=!1))},pt=e=>{const t=e.childNodes;let n,s,$,o,l,a;for(s=0,$=t.length;s<$;s++)if(n=t[s],1===n.nodeType){if(n["s-sr"])for(l=n["s-sn"],n.hidden=!1,o=0;o<$;o++)if(a=t[o].nodeType,t[o]["s-hn"]!==n["s-hn"]||""!==l){if(1===a&&l===t[o].getAttribute("slot")){n.hidden=!0;break}}else if(1===a||3===a&&""!==t[o].textContent.trim()){n.hidden=!0;break}pt(n)}},gt=[],yt=e=>{let t,n,s,$,o,l,a=0;const r=e.childNodes,i=r.length;for(;a<i;a++){if(t=r[a],t["s-sr"]&&(n=t["s-cr"])&&n.parentNode)for(s=n.parentNode.childNodes,$=t["s-sn"],l=s.length-1;l>=0;l--)n=s[l],n["s-cn"]||n["s-nr"]||n["s-hn"]===t["s-hn"]||(vt(n,$)?(o=gt.find((e=>e.$nodeToRelocate$===n)),Se=!0,n["s-sn"]=n["s-sn"]||$,o?o.$slotRefNode$=t:gt.push({$slotRefNode$:t,$nodeToRelocate$:n}),n["s-sr"]&&gt.map((e=>{vt(e.$nodeToRelocate$,n["s-sn"])&&(o=gt.find((e=>e.$nodeToRelocate$===n)),o&&!e.$slotRefNode$&&(e.$slotRefNode$=o.$slotRefNode$))}))):gt.some((e=>e.$nodeToRelocate$===n))||gt.push({$nodeToRelocate$:n}));1===t.nodeType&&yt(t)}},vt=(e,t)=>1===e.nodeType?null===e.getAttribute("slot")&&""===t||e.getAttribute("slot")===t:e["s-sn"]===t||""===t,bt=e=>{U&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(bt))},wt=(e,t)=>{const n=e.$hostElement$,s=e.$cmpMeta$,$=e.$vnode$||_e(null,null),o=qe(t)?t:Ue(null,null,t);if(be=n.tagName,Y&&Array.isArray(t)&&t.some(qe))throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of "${be.toLowerCase()}" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);if(k&&s.$attrsToReflect$&&(o.$attrs$=o.$attrs$||{},s.$attrsToReflect$.map((e=>{let[t,s]=e;return o.$attrs$[s]=n[t]}))),o.$tag$=null,o.$flags$|=4,e.$vnode$=o,o.$elm$=$.$elm$=C&&n.shadowRoot||n,(R||C)&&(ye=n["s-sc"]),ne&&(ve=n["s-cr"],xe=fn&&0!==(1&s.$flags$),Se=!1),ut($,o),ne){if(mn.$flags$|=1,ke){let e,t,n,s,$,l;yt(o.$elm$);let a=0;for(;a<gt.length;a++)e=gt[a],t=e.$nodeToRelocate$,t["s-ol"]||(n=X||K?xt(t):cn.createTextNode(""),n["s-nr"]=t,t.parentNode.insertBefore(t["s-ol"]=n,t));for(a=0;a<gt.length;a++)if(e=gt[a],t=e.$nodeToRelocate$,e.$slotRefNode$){for(s=e.$slotRefNode$.parentNode,$=e.$slotRefNode$.nextSibling,n=t["s-ol"];n=n.previousSibling;)if(l=n["s-nr"],l&&l["s-sn"]===t["s-sn"]&&s===l.parentNode&&(l=l.nextSibling,!l||!l["s-nr"])){$=l;break}(!$&&s!==t.parentNode||t.nextSibling!==$)&&t!==$&&(!t["s-hn"]&&t["s-ol"]&&(t["s-hn"]=t["s-ol"].parentNode.nodeName),s.insertBefore(t,$))}else 1===t.nodeType&&(t.hidden=!0)}Se&&pt(o.$elm$),mn.$flags$&=-2,gt.length=0}},Nt=e=>cn.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${be.toLowerCase()})`),xt=e=>cn.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),St=(e,t)=>{he&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise((t=>e.$onRenderResolve$=t)))},kt=(e,t)=>{if(F&&M&&(e.$flags$|=16),he&&4&e.$flags$)return void(e.$flags$|=512);St(e,e.$ancestorComponent$);const n=()=>Rt(e,t);return F?kn(n):n()},Rt=(e,t)=>{const n=e.$hostElement$,s=je("scheduleUpdate",e.$cmpMeta$.$tagName$),$=ee?e.$lazyInstance$:n;let o;return t?(ee&&h&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map((e=>{let[t,n]=e;return jt($,t,n)})),e.$queuedListeners$=null)),Ot(n,"componentWillLoad"),r&&(o=jt($,"componentWillLoad"))):(Ot(n,"componentWillUpdate"),i&&(o=jt($,"componentWillUpdate"))),Ot(n,"componentWillRender"),c&&(o=Mt(o,(()=>jt($,"componentWillRender")))),s(),Mt(o,(()=>Ct(e,$,t)))},Ct=async(e,t,n)=>{const s=e.$hostElement$,$=je("update",e.$cmpMeta$.$tagName$),o=s["s-rc"];A&&n&&nt(e);const l=je("render",e.$cmpMeta$.$tagName$);if(Y&&(e.$flags$|=1024),K?await Tt(e,t,s):Tt(e,t,s),ie&&mn.$cssShim$&&mn.$cssShim$.updateHost(s),Y&&(e.$renderCount$++,e.$flags$&=-1025),K)try{Pt(s),n&&(1&e.$cmpMeta$.$flags$?s["s-en"]="":2&e.$cmpMeta$.$flags$&&(s["s-en"]="c"))}catch(a){en(a,s)}if(he&&o&&(o.map((e=>e())),s["s-rc"]=void 0),l(),$(),he){const t=s["s-p"],n=()=>Lt(e);0===t.length?n():(Promise.all(t).then(n),e.$flags$|=4,t.length=0)}else Lt(e)},Tt=(e,t,n)=>{const $=!!s,o=!!ee,l=!!F,a=!!M;try{if(Ce=t,t=($||t.render)&&t.render(),a&&l&&(e.$flags$&=-17),(a||o)&&(e.$flags$|=2),f||k)if(z||k){if(K)return Promise.resolve(t).then((t=>wt(e,t)));wt(e,t)}else n.textContent=t}catch(r){en(r,e.$hostElement$)}return Ce=null,null},Lt=e=>{const t=e.$cmpMeta$.$tagName$,n=e.$hostElement$,s=je("postUpdate",t),o=ee?e.$lazyInstance$:n,r=e.$ancestorComponent$;a&&(Y&&(e.$flags$|=1024),jt(o,"componentDidRender"),Y&&(e.$flags$&=-1025)),Ot(n,"componentDidRender"),64&e.$flags$?(l&&(Y&&(e.$flags$|=1024),jt(o,"componentDidUpdate"),Y&&(e.$flags$&=-1025)),Ot(n,"componentDidUpdate"),s()):(e.$flags$|=64,he&&L&&It(n),$&&(Y&&(e.$flags$|=2048),jt(o,"componentDidLoad"),Y&&(e.$flags$&=-2049)),Ot(n,"componentDidLoad"),s(),he&&(e.$onReadyResolve$(n),r||At(t))),J&&n["s-hmr-load"]&&n["s-hmr-load"](),w&&ee&&e.$onInstanceResolve$(n),he&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),512&e.$flags$&&xn((()=>kt(e,!1))),e.$flags$&=-517)},Et=e=>{if(M){const t=Kt(e),n=t.$hostElement$.isConnected;return n&&2===(18&t.$flags$)&&kt(t,!1),n}return!1},At=e=>{L&&It(cn.documentElement),ue&&(mn.$flags$|=2),xn((()=>Ze(rn,"appload",{detail:{namespace:ge}}))),te&&performance.measure&&performance.measure(`[Stencil] ${ge} initial load (by ${e})`,"st:app:start")},jt=(e,t,n)=>{if(e&&e[t])try{return e[t](n)}catch(s){en(s)}},Mt=(e,t)=>e&&e.then?e.then(t):t(),Ot=(e,t)=>{Q&&Ze(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:ge}})},It=e=>$e?e.classList.add("hydrated"):se?e.setAttribute("hydrated",""):void 0,Pt=e=>{const t=e.children;if(null!=t)for(let n=0,s=t.length;n<s;n++){const e=t[n];"function"===typeof e.connectedCallback&&e.connectedCallback(),Pt(e)}},Ht=(e,t,n,s)=>{const $=Kt(e),o=ee?$.$hostElement$:e,l=$.$instanceValues$.get(t),a=$.$flags$,r=ee?$.$lazyInstance$:o;var i,c;i=n,c=s.$members$[t][0],n=null==i||Be(i)?i:le&&4&c?"false"!==i&&(""===i||!!i):ae&&2&c?parseFloat(i):re&&1&c?String(i):i;const d=Number.isNaN(l)&&Number.isNaN(n);if((!ee||!(8&a)||void 0===l)&&(n!==l&&!d)&&($.$instanceValues$.set(t,n),Y&&(1024&$.$flags$?sn(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,"\nElement",o,"\nNew value",n,"\nOld value",l):2048&$.$flags$&&sn(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,"\nElement",o,"\nNew value",n,"\nOld value",l)),!ee||r)){if(V&&s.$watchers$&&128&a){const e=s.$watchers$[t];e&&e.map((e=>{try{r[e](n,l,t)}catch(s){en(s,o)}}))}if(M&&2===(18&a)){if(de&&r.componentShouldUpdate&&!1===r.componentShouldUpdate(n,l,t))return;kt($,!1)}}},Bt=(e,t,n)=>{if(b&&t.$members$){V&&e.watchers&&(t.$watchers$=e.watchers);const s=Object.entries(t.$members$),$=e.prototype;if(s.map((e=>{let[s,[o]]=e;(S||E)&&(31&o||(!ee||2&n)&&32&o)?Object.defineProperty($,s,{get(){return e=s,Kt(this).$instanceValues$.get(e);var e},set(e){if(Y){const e=Kt(this);0===(1&n)&&0===(8&e.$flags$)&&0!==(31&o)&&0===(1024&o)&&sn(`@Prop() "${s}" on <${t.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`)}Ht(this,s,e,t)},configurable:!0,enumerable:!0}):ee&&w&&1&n&&64&o&&Object.defineProperty($,s,{value(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const $=Kt(this);return $.$onInstancePromise$.then((()=>$.$lazyInstance$[s](...t)))}})})),x&&(!ee||1&n)){const n=new Map;$.attributeChangedCallback=function(e,t,s){mn.jmp((()=>{const t=n.get(e);if(this.hasOwnProperty(t))s=this[t],delete this[t];else if($.hasOwnProperty(t)&&"number"===typeof this[t]&&this[t]==s)return;this[t]=(null!==s||"boolean"!==typeof this[t])&&s}))},e.observedAttributes=s.filter((e=>{let[t,n]=e;return 15&n[0]})).map((e=>{let[s,$]=e;const o=$[1]||s;return n.set(o,s),k&&512&$[0]&&t.$attrsToReflect$.push([s,o]),o}))}}return e},Dt=async(e,t,s,$,o)=>{if((ee||K||A)&&0===(32&t.$flags$)){if(ee||Z){if(t.$flags$|=32,(o=on(s,t,$)).then){const e=(l=`st:load:${s.$tagName$}:${t.$modeName$}`,a=`[Stencil] Load module for <${s.$tagName$}>`,te&&performance.mark?(0===performance.getEntriesByName(l,"mark").length&&performance.mark(l),()=>{0===performance.getEntriesByName(a,"measure").length&&performance.measure(a,l)}):()=>{});o=await o,e()}if((Y||X)&&!o)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);b&&!o.isProxied&&(V&&(s.$watchers$=o.watchers),Bt(o,s,2),o.isProxied=!0);const e=je("createInstance",s.$tagName$);b&&(t.$flags$|=8);try{new o(t)}catch(c){en(c)}b&&(t.$flags$&=-9),V&&(t.$flags$|=128),e(),Ut(t.$lazyInstance$)}else o=e.constructor,t.$flags$|=32,customElements.whenDefined(s.$tagName$).then((()=>t.$flags$|=128));if(A&&o.style){let $=o.style;N&&"string"!==typeof $&&($=$[t.$modeName$=Ge(e)],K&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));const l=st(s,t.$modeName$);if(!ln.has(l)){const e=je("registerStyles",s.$tagName$);!K&&C&&oe&&8&s.$flags$&&($=await n.e(49311).then(n.bind(n,49311)).then((e=>e.scopeCss($,l,!1)))),et(l,$,!!(1&s.$flags$)),e()}}}var l,a;const r=t.$ancestorComponent$,i=()=>kt(t,!0);he&&r&&r["s-rc"]?r["s-rc"].push(i):i()},Ut=e=>{ee&&d&&jt(e,"connectedCallback")},_t=e=>{if(0===(1&mn.$flags$)){const t=Kt(e),n=t.$cmpMeta$,s=je("connectedCallback",n.$tagName$);if(y&&Ft(e,t,n.$listeners$,!0),1&t.$flags$)Ft(e,t,n.$listeners$,!1),Ut(t.$lazyInstance$);else{let s;if(t.$flags$|=1,Z&&(s=e.getAttribute(Me),s)){if(C&&fn&&1&n.$flags$){const t=N?tt(e.shadowRoot,n,e.getAttribute("s-mode")):tt(e.shadowRoot,n);e.classList.remove(t+"-h",t+"-s")}((e,t,n,s)=>{const $=je("hydrateClient",t),o=e.shadowRoot,l=[],a=C&&o?[]:null,r=s.$vnode$=_e(t,null);mn.$orgLocNodes$||Ye(cn.body,mn.$orgLocNodes$=new Map),e[Me]=n,e.removeAttribute(Me),Xe(r,l,[],a,e,e,n),l.map((e=>{const n=e.$hostId$+"."+e.$nodeId$,s=mn.$orgLocNodes$.get(n),$=e.$elm$;s&&fn&&""===s["s-en"]&&s.parentNode.insertBefore($,s.nextSibling),o||($["s-hn"]=t,s&&($["s-ol"]=s,$["s-ol"]["s-nr"]=$)),mn.$orgLocNodes$.delete(n)})),C&&o&&a.map((e=>{e&&o.appendChild(e)})),$()})(e,n.$tagName$,s,t)}if(ne&&!s&&(K||(T||C)&&12&n.$flags$)&&zt(e),he){let n=e;for(;n=n.parentNode||n.host;)if(Z&&1===n.nodeType&&n.hasAttribute("s-id")&&n["s-p"]||n["s-p"]){St(t,t.$ancestorComponent$=n);break}}S&&!K&&n.$members$&&Object.entries(n.$members$).map((t=>{let[n,[s]]=t;if(31&s&&e.hasOwnProperty(n)){const t=e[n];delete e[n],e[n]=t}})),fe?xn((()=>Dt(e,t,n))):Dt(e,t,n)}s()}},zt=e=>{const t=e["s-cr"]=cn.createComment(X?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},qt=e=>{if(0===(1&mn.$flags$)){const t=Kt(e),n=ee?t.$lazyInstance$:e;h&&t.$rmListeners$&&(t.$rmListeners$.map((e=>e())),t.$rmListeners$=void 0),ie&&mn.$cssShim$&&mn.$cssShim$.removeHost(e),ee&&m&&jt(n,"disconnectedCallback"),o&&jt(n,"componentDidUnload")}},Wt=(e,t)=>{const n={$flags$:t[0],$tagName$:t[1]};b&&(n.$members$=t[2]),h&&(n.$listeners$=t[3]),V&&(n.$watchers$=e.$watchers$),k&&(n.$attrsToReflect$=[]),C&&!fn&&1&n.$flags$&&(n.$flags$|=8);const s=e.prototype.connectedCallback,$=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){Zt(this,n)},connectedCallback(){_t(this),d&&s&&s.call(this)},disconnectedCallback(){qt(this),m&&$&&$.call(this)},__attachShadow(){fn?me?this.attachShadow({mode:"open",delegatesFocus:!!(16&n.$flags$)}):this.attachShadow({mode:"open"}):this.shadowRoot=this}}),e.is=n.$tagName$,Bt(e,n,3)},Vt=(e,t)=>t,Ft=(e,t,n,s)=>{h&&n&&(y&&(n=s?n.filter((e=>{let[t]=e;return 32&t})):n.filter((e=>{let[t]=e;return!(32&t)}))),n.map((n=>{let[s,$,o]=n;const l=v?Xt(e,s):e,a=Jt(t,o),r=Yt(s);mn.ael(l,$,a,r),(t.$rmListeners$=t.$rmListeners$||[]).push((()=>mn.rel(l,$,a,r)))})))},Jt=(e,t)=>n=>{try{ee?256&e.$flags$?e.$lazyInstance$[t](n):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,n]):e.$hostElement$[t](n)}catch(s){en(s)}},Xt=(e,t)=>p&&4&t?cn:u&&8&t?rn:g&&16&t?cn.body:y&&32&t?e.parentElement:e,Yt=e=>hn?{passive:0!==(1&e),capture:0!==(2&e)}:0!==(2&e),Gt=new WeakMap,Kt=e=>Gt.get(e),Zt=(e,t)=>{const n={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return Y&&(n.$renderCount$=0),w&&ee&&(n.$onInstancePromise$=new Promise((e=>n.$onInstanceResolve$=e))),he&&(n.$onReadyPromise$=new Promise((e=>n.$onReadyResolve$=e)),e["s-p"]=[],e["s-rc"]=[]),Ft(e,n,t.$listeners$,!1),Gt.set(e,n)},Qt=(e,t)=>t in e,en=(e,t)=>(we||console.error)(e,t),tn=G?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],nn=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return console.error(...tn,...t)},sn=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return console.warn(...tn,...t)},$n=new Map,on=(e,t,s)=>{const $=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$;if(Y&&"string"!==typeof o)return void nn(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);const l=!J&&$n.get(o);return l?l[$]:n(60141)(`./${o}.entry.js${J&&s?"?s-hmr="+s:""}`).then((e=>(J||$n.set(o,e),e[$])),en)},ln=new Map,an=[],rn="undefined"!==typeof window?window:{},cn=(ie&&rn.CSS,rn.document||{head:{}}),dn=rn.HTMLElement||class{},mn={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,s)=>e.addEventListener(t,n,s),rel:(e,t,n,s)=>e.removeEventListener(t,n,s),ce:(e,t)=>new CustomEvent(e,t)},fn=!oe||!C||(()=>(cn.head.attachShadow+"").indexOf("[native")>-1)(),hn=(()=>{let e=!1;try{cn.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch(t){}return e})(),un=!!ce&&(()=>{try{return new CSSStyleSheet,"function"===typeof(new CSSStyleSheet).replaceSync}catch(e){}return!1})(),pn=[],gn=[],yn=[],vn=(e,t)=>n=>{e.push(n),Le||(Le=!0,t&&4&mn.$flags$?xn(Nn):mn.raf(Nn))},bn=e=>{for(let n=0;n<e.length;n++)try{e[n](performance.now())}catch(t){en(t)}e.length=0},wn=(e,t)=>{let n=0,s=0;for(;n<e.length&&(s=performance.now())<t;)try{e[n++](s)}catch($){en($)}n===e.length?e.length=0:0!==n&&e.splice(0,n)},Nn=()=>{if(ue&&Te++,bn(pn),ue){const e=2===(6&mn.$flags$)?performance.now()+14*Math.ceil(.1*Te):1/0;wn(gn,e),wn(yn,e),gn.length>0&&(yn.push(...gn),gn.length=0),(Le=pn.length+gn.length+yn.length>0)?mn.raf(Nn):Te=0}else bn(gn),(Le=pn.length>0)&&mn.raf(Nn)},xn=e=>{return Promise.resolve(t).then(e);var t},Sn=vn(pn,!1),kn=vn(gn,!0)}}]);
//# sourceMappingURL=33850.eac31dd8.chunk.js.map