"use strict";(self.webpackChunkn2_compile=self.webpackChunkn2_compile||[]).push([[69229],{32500:(e,t,i)=>{i.d(t,{I:()=>f,b:()=>_});var a=i(37081),r=i(33280),s=i(94951),n=i(15226),o=i(26461),l=i(116),h=i(41012),d=i(58406),c=i(98634),u=i(64201),p=i(19253),g=i(25920),m=i(4760);function _(e){const t=new u.kG,{vertex:i,fragment:_}=t;return(0,h.Sv)(i,e),t.include(s.w,e),t.attributes.add(m.T.POSITION,"vec3"),t.attributes.add(m.T.UV0,"vec2"),e.perspectiveInterpolation&&t.attributes.add(m.T.PERSPECTIVEDIVIDE,"float"),t.varyings.add("vpos","vec3"),e.multipassEnabled&&t.varyings.add("depth","float"),i.code.add(c.H`
    void main(void) {
      vpos = position;
      ${e.multipassEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      vTexCoord = uv0;
      gl_Position = transformPosition(proj, view, vpos);

      ${e.perspectiveInterpolation?"gl_Position *= perspectiveDivide;":""}
    }
  `),t.include(r.f5,e),t.include(n.l,e),_.uniforms.add(new p.A("tex",(e=>e.texture)),new d.p("opacity",(e=>e.opacity))),t.varyings.add("vTexCoord","vec2"),e.output===a.H_.Alpha?_.code.add(c.H`
    void main() {
      discardBySlice(vpos);
      ${e.multipassEnabled?"terrainDepthTest(depth);":""}

      float alpha = texture(tex, vTexCoord).a * opacity;
      if (alpha  < ${c.H.float(o.F)}) {
        discard;
      }

      fragColor = vec4(alpha);
    }
    `):(_.include(l.Y),_.code.add(c.H`
    void main() {
      discardBySlice(vpos);
      ${e.multipassEnabled?"terrainDepthTest(depth);":""}
      fragColor = texture(tex, vTexCoord) * opacity;

      if (fragColor.a < ${c.H.float(o.F)}) {
        discard;
      }

      fragColor = highlightSlice(fragColor, vpos);
      ${e.transparencyPassType===g.A.Color?"fragColor = premultiplyAlpha(fragColor);":""}
    }
    `)),t}const f=Object.freeze(Object.defineProperty({__proto__:null,build:_},Symbol.toStringTag,{value:"Module"}))},69229:(e,t,i)=>{i.d(t,{Z:()=>V});var a=i(27366),r=i(14921),s=i(42537),n=i(32718),o=i(92026),l=i(66978),h=i(94172),d=i(49861),c=(i(93169),i(84936),i(69912)),u=i(53866),p=i(65156),g=i(26279),m=i(42069),_=i(86372),f=i(38461),y=i(91526),v=i(40779),w=i(70619),x=i(4760);function b(e,t){return(0,w.g7)(e,[[t[0],t[1],-1],[t[2],t[1],-1],[t[2],t[3],-1],[t[0],t[3],-1]])}function S(e,t,i){if(!(0,p.kK)(t,i))return b(e,i);const a=[t[1]-i[1],Math.min(t[3],i[3])-Math.max(t[1],i[1]),i[3]-t[3],123456],r=[t[0]-i[0],Math.min(t[2],i[2])-Math.max(t[0],i[0]),i[2]-t[2],123456],s=i[2]-i[0],n=i[3]-i[1],o=r[0]>0&&r[2]>0?3:2,l=a[0]>0&&a[2]>0?3:2,h=(l+1)*(o+1),d=(0,_.bg)(3*h),c=(0,f.xx)(2*h),u=new Array(6*(l*o-1));let g=0,m=0,w=0,S=0,R=0;for(let p=0;p<4;p++){const e=a[p];if(e<=0)continue;let t=0;for(let a=0;a<4;a++){const e=r[a];e<=0||(d[m++]=i[0]+t,d[m++]=i[1]+g,d[m++]=-1,c[w++]=t/s,c[w++]=g/n,a<3&&p<3&&(1!==a||1!==p)&&(u[R++]=S,u[R++]=S+1,u[R++]=S+o+1,u[R++]=S+1,u[R++]=S+o+2,u[R++]=S+o+1),S++,t+=e)}g+=e}const I=new Array(u.length);return new v.Z(e,[[x.T.POSITION,new y.a(d,u,3,!0)],[x.T.NORMAL,new y.a(E,I,3,!0)],[x.T.UV0,new y.a(c,u,2,!0)]])}const E=[0,0,1];var R=i(61712),I=i(94463),P=i(54134),C=i(78289),T=i(39077),A=i(1487),O=i(78485),D=i(66156),M=i(67581),H=i(13107),L=i(69787),N=i(8548);let G=class extends((0,H.Z)((0,m.A)(M.Z))){constructor(){super(...arguments),this.drapeSourceType=g.Lw.RasterImage,this.updatePolicy=O.j.SYNC,this.fullExtentInLocalViewSpatialReference=null,this.maximumDataResolution=null,this._images=new Array,this._extents=new Array,this._overlays=new Array,this.updateWhenStationary=!0,this._drapeSourceRenderer=null,this.refreshDebounced=(0,l.Ds)((async e=>{this.destroyed||await this._doRefresh(e).catch((e=>{(0,l.D_)(e)||n.Z.getLogger(this).error(e)}))}),2e3)}initialize(){this._drapeSourceRenderer=this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this),this.addHandles((0,s.kB)((()=>this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this)))),this.addResolvingPromise((0,R.E)(this).then((e=>this._set("fullExtentInLocalViewSpatialReference",e)))),this._updatingHandles.add((()=>this.suspended),(()=>this._suspendedChangeHandler())),this.addHandles(this.view.resourceController.scheduler.registerIdleStateCallbacks((()=>{this._isScaleRangeActive()&&this.notifyChange("suspended")}),(()=>{}))),this._isScaleRangeLayer()&&this._updatingHandles.add((()=>this.layer.effectiveScaleRange),(()=>this.notifyChange("suspended")))}destroy(){this.clear()}setDrapingExtent(e,t){this._spatialReference=t,e.forEach(((e,t)=>{this._overlays[t]=e,this._updateImageExtent(e,t)}))}_updateImageExtent(e,t){const i=this._clippedExtent(e.extent,U);if(null==i)return;const a=function(e,t,i){const a=(0,p.d_)(e)/(0,p.Cb)(e),r={width:i,height:i};return a>1.0001?r.height=i/a:a<.9999&&(r.width=i*a),r.width=Math.round(r.width/((0,p.d_)(e)/(0,p.d_)(t))),r.height=Math.round(r.height/((0,p.Cb)(e)/(0,p.Cb)(t))),r}(e.extent,i,e.resolution);let r=e.pixelRatio*this.view.state.pixelRatio;const{layer:s}=this;if("imageMaxWidth"in s&&null!=s.imageMaxWidth||"imageMaxHeight"in s&&null!=s.imageMaxHeight){const e=s.imageMaxWidth,t=s.imageMaxHeight;if(a.width>e){const t=e/a.width;a.height=Math.floor(a.height*t),a.width=e,r*=t}if(a.height>t){const e=t/a.height;a.width=Math.floor(a.width*e),a.height=t,r*=e}}const o=this._extents[t];o&&(0,p.fS)(o.extent,i)&&this._imageSizeEquals(i,o.imageSize,a)||(this._extents[t]={extent:(0,p.Ue)(i),imageSize:a,pixelRatio:r},this.suspended||this._fetch(t).catch((e=>{(0,l.D_)(e)||n.Z.getLogger(this).error(e)})))}clear(){for(let e=0;e<this._images.length;e++)this._clearImage(e)}async doRefresh(){return this._doRefresh()}async _doRefresh(e){if(this.suspended)return;const t=[];for(let i=0;i<this._extents.length;i++)this._extents[i]&&t.push(this._fetch(i,e));await Promise.allSettled(t)}canResume(){if(!super.canResume())return!1;const e=this.layer;if(this._isScaleRangeActive()){const{minScale:t,maxScale:i}=e.effectiveScaleRange,a=this.view.scale;if(a<i||t>0&&a>t)return!1}return!0}async processResult(e,t,i){(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement)&&(e.image=t)}findExtentInfoAt(e){for(const t of this._extents){const i=t.extent;if(new u.Z(i[0],i[1],i[2],i[3],this._spatialReference).contains(e))return t}return null}getFetchOptions(){}async redraw(e,t){await(0,r.Ed)(this._images,(async(i,a)=>{i&&(await e(i,t),await this._createStageObjects(a,i.image,t))}))}_imageSizeEquals(e,t,i){if(!this.maximumDataResolution)return!1;const a=(0,p.d_)(e)/this.maximumDataResolution.x,r=(0,p.Cb)(e)/this.maximumDataResolution.y,s=a/t.width,n=r/t.height,o=a/i.width,l=r/i.height,h=Math.abs(s-o),d=Math.abs(n-l),c=I.h.TESTS_DISABLE_OPTIMIZATIONS?0:1.5;return h<=c&&d<=c}async _fetch(e,t){if(this.suspended)return;const i=this._extents[e],a=i.extent;this._images[e]||(this._images[e]={texture:null,material:null,renderGeometry:null,loadingPromise:null,loadingAbortController:null,image:null,pixelData:null,renderExtent:(0,p.Ue)(a)});const r=this._images[e];r.loadingAbortController=(0,o.IM)(r.loadingAbortController);const s=new u.Z(a[0],a[1],a[2],a[3],this._spatialReference);if(0===s.width||0===s.height)return void this._clearImage(e);const h=new AbortController;r.loadingAbortController=h,(0,l.fu)(t,(()=>h.abort()));const d=h.signal,c=this._waitFetchReady(d).then((async()=>{const t={requestAsImageElement:!0,pixelRatio:this._overlays[e].pixelRatio,...this.getFetchOptions(),signal:d},{height:a,width:r}=i.imageSize;return this.layer.fetchImage(s,r,a,t)})).then((e=>{if((0,l.Hc)(d))throw n.Z.getLogger(this).warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."),(0,l.zE)();return this.processResult(r,e)})).then((()=>{(0,p.JG)(r.renderExtent,a)}));r.loadingPromise=c,await this._updatingHandles.addPromise(c.then((async()=>{(0,l.k_)(d),await this._createStageObjects(e,r.image,d)})).catch((e=>{throw e&&!(0,l.D_)(e)&&n.Z.getLogger(this).error(e),e})).finally((()=>{c===r.loadingPromise&&(r.loadingPromise=null,r.loadingAbortController=null)})))}_clearImage(e){const t=this._images[e];if(t){null!=t.renderGeometry&&(this._drapeSourceRenderer.removeGeometries([t.renderGeometry],C.T.UPDATE),t.renderGeometry=null);const e=this.view._stage,i=t.texture;i?.unload(),e.remove(i),t.texture=null,e.remove(t.material),t.material=null,t.loadingAbortController=(0,o.IM)(t.loadingAbortController),t.loadingPromise=null,t.image=null,t.pixelData=null}}async _createStageObjects(e,t,i){const a=this.view._stage,s=this._images[e],n=()=>{s.texture?.unload(),a.remove(s.texture),s.texture=null,s.renderGeometry&&(this._drapeSourceRenderer.removeGeometries([s.renderGeometry],C.T.UPDATE),s.renderGeometry=null)};if(t){const o=new A.x(t,{width:t.width,height:t.height,preMultiplyAlpha:!0,wrap:{s:N.e8.CLAMP_TO_EDGE,t:N.e8.CLAMP_TO_EDGE}});let h;if(await(0,r.q6)(this._images[e===P.fu.INNER?P.fu.OUTER:P.fu.INNER].loadingPromise),(0,l.k_)(i),n(),await a.schedule((()=>o.load(a.renderView.renderingContext)),i),a.add(o),s.texture=o,null==s.material?(s.material=new D.j({transparent:!0,textureId:o.id}),a.add(s.material)):s.material.setParameters({textureId:o.id}),e===P.fu.INNER)h=b(s.material,s.renderExtent);else{const e=this._images[0].renderExtent;if(!e)return void n();h=S(s.material,e,s.renderExtent)}s.renderGeometry=new T.z(h),s.renderGeometry.localOrigin=this._overlays[e].renderLocalOrigin,this._drapeSourceRenderer.addGeometries([s.renderGeometry],C.T.UPDATE)}else n(),a.remove(s.material),s.material=null}_isScaleRangeLayer(){return"effectiveScaleRange"in this.layer}_isScaleRangeActive(){const e=this.layer;if(!this._isScaleRangeLayer())return!1;const{minScale:t,maxScale:i}=e.effectiveScaleRange;return(0,L.Av)(t,i)}_clippedExtent(e,t){if("local"!==this.view.viewingMode)return(0,p.JG)(t,e);const i=this.view.basemapTerrain;return i.ready?(0,p.jV)(e,i.extent,t):(0,p.JG)(t,e)}_suspendedChangeHandler(){this.suspended?this.clear():this.refreshDebounced()}async _waitFetchReady(e){await(0,h.N1)((()=>this.view.stationary),e),(0,l.k_)(e)}};(0,a._)([(0,d.Cb)()],G.prototype,"layer",void 0),(0,a._)([(0,d.Cb)()],G.prototype,"suspended",void 0),(0,a._)([(0,d.Cb)({readOnly:!0})],G.prototype,"fullExtentInLocalViewSpatialReference",void 0),(0,a._)([(0,d.Cb)()],G.prototype,"updating",void 0),G=(0,a._)([(0,c.j)("esri.views.3d.layers.DynamicLayerView3D")],G);const V=G,U=(0,p.Ue)()},42069:(e,t,i)=>{i.d(t,{A:()=>d});var a=i(27366),r=i(42537),s=i(66978),n=i(94172),o=i(49861),l=(i(93169),i(32718),i(84936),i(69912)),h=i(5354);const d=e=>{let t=class extends e{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(e){super.postscript(e),(0,h.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}async _validateHeightModelInfo(){const e=new AbortController,t=e.signal;this.addHandles((0,r.kB)((()=>e.abort()))),await(0,n.N1)((()=>this.view.defaultsFromMap?.heightModelInfoReady),t),(0,s.k_)(t);const i=(0,h.Wt)(this.layer,this.view.heightModelInfo,this.supportsHeightUnitConversion);if(i)throw i}canResume(){const e=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return super.canResume()&&(!e?.minScale||!e.maxScale||e.minScale>=e.maxScale)}getSuspendInfo(){const e=super.getSuspendInfo(),t=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return t&&t.minScale&&t.maxScale&&t.minScale<t.maxScale&&(e.outsideScaleRange=!0),e}};return(0,a._)([(0,o.Cb)()],t.prototype,"view",void 0),(0,a._)([(0,o.Cb)()],t.prototype,"slicePlaneEnabled",void 0),t=(0,a._)([(0,l.j)("esri.views.3d.layers.LayerView3D")],t),t}},61712:(e,t,i)=>{i.d(t,{E:()=>s});var a=i(81753),r=i(67387);function s(e){const t=e.view.spatialReference,i=e.layer.fullExtent,s=null!=i&&i.spatialReference;if(null==i||!s)return Promise.resolve(null);if(s.equals(t))return Promise.resolve(i.clone());const n=(0,a.iV)(i,t);return null!=n?Promise.resolve(n):e.view.state.isLocal?(0,r.projectGeometry)(i,t,e.layer.portalItem).then((t=>!e.destroyed&&t?t:null)).catch((()=>null)):Promise.resolve(null)}},66156:(e,t,i)=>{i.d(t,{j:()=>O});var a=i(25158),r=i(37081),s=i(68401),n=i(17363),o=i(56529),l=i(78041),h=i(93822),d=i(97731),c=i(4760),u=i(12594),p=i(64642),g=i(11983),m=i(33236),_=i(27366),f=(i(98634),i(82144)),y=i(31132),v=i(33559),w=i(27627),x=i(50411),b=i(25920),S=i(8883),E=i(32500),R=i(8548),I=i(36207);class P extends y.A{initializeProgram(e){return new w.$(e.rctx,P.shader.get().build(this.configuration),A)}_setPipelineState(e,t){const i=this.configuration,a=e===b.A.NONE,s=e===b.A.FrontFace;return(0,I.sm)({blending:i.output!==r.H_.Color&&i.output!==r.H_.Alpha||!i.transparent?null:a?C:(0,l.j7)(e),culling:(0,I.zp)(i.cullFace),depthTest:{func:(0,l.Bh)(e)},depthWrite:a?i.writeDepth?I.LZ:null:(0,l.K5)(e),colorWrite:I.BK,stencilWrite:i.hasOccludees?x.s3:null,stencilTest:i.hasOccludees?t?x.eD:x.RY:null,polygonOffset:a||s?null:(0,l.je)(i.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._setPipelineState(this.configuration.transparencyPassType,!0),this._setPipelineState(this.configuration.transparencyPassType,!1)}getPipeline(e){return e?this._occludeePipelineState:super.getPipeline()}}P.shader=new f.J(E.I,(()=>i.e(18957).then(i.bind(i,18957))));const C=(0,I.if)(R.zi.ONE,R.zi.ONE_MINUS_SRC_ALPHA);class T extends S.W{constructor(){super(...arguments),this.output=r.H_.Color,this.cullFace=s.Vr.None,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=b.A.NONE,this.multipassEnabled=!1,this.cullAboveGround=!1,this.perspectiveInterpolation=!0}}(0,_._)([(0,v.o)({count:r.H_.COUNT})],T.prototype,"output",void 0),(0,_._)([(0,v.o)({count:s.Vr.COUNT})],T.prototype,"cullFace",void 0),(0,_._)([(0,v.o)()],T.prototype,"hasSlicePlane",void 0),(0,_._)([(0,v.o)()],T.prototype,"transparent",void 0),(0,_._)([(0,v.o)()],T.prototype,"enableOffset",void 0),(0,_._)([(0,v.o)()],T.prototype,"writeDepth",void 0),(0,_._)([(0,v.o)()],T.prototype,"hasOccludees",void 0),(0,_._)([(0,v.o)({count:b.A.COUNT})],T.prototype,"transparencyPassType",void 0),(0,_._)([(0,v.o)()],T.prototype,"multipassEnabled",void 0),(0,_._)([(0,v.o)()],T.prototype,"cullAboveGround",void 0),(0,_._)([(0,v.o)()],T.prototype,"perspectiveInterpolation",void 0),(0,_._)([(0,v.o)({constValue:!1})],T.prototype,"occlusionPass",void 0);const A=new Map([[c.T.POSITION,0],[c.T.UV0,2],[c.T.PERSPECTIVEDIVIDE,3]]);class O extends g.c{constructor(e){super(e,new H),this.supportsEdges=!0,this.produces=new Map([[h.r.OPAQUE_MATERIAL,e=>e===r.H_.Highlight||(0,r.NM)(e)&&!this.parameters.transparent],[h.r.TRANSPARENT_MATERIAL,e=>(0,r.NM)(e)&&this.parameters.transparent&&this.parameters.writeDepth],[h.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,e=>(0,r.NM)(e)&&this.parameters.transparent&&!this.parameters.writeDepth],[h.r.DRAPED_MATERIAL,e=>(0,r.g)(e)]]),this._vertexAttributeLocations=A,this._configuration=new T}getConfiguration(e,t){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.enableOffset=t.camera.relativeElevation<l.ve,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration.perspectiveInterpolation=this.parameters.perspectiveInterpolation,this._configuration}createGLMaterial(e){return new D(e)}createBufferWriter(){const e=p.W1.clone();return this.parameters.perspectiveInterpolation&&e.f32(c.T.PERSPECTIVEDIVIDE),new M(e)}}class D extends n.F{constructor(e){super({...e,...e.material.parameters})}_updateParameters(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.ensureTechnique(P,e)}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&(this._material.setParameters({hasOccludees:e.hasOccludees}),this._updateParameters(e))}beginSlot(e){return this._output!==r.H_.Color&&this._output!==r.H_.Alpha||this._updateOccludeeState(e),this._updateParameters(e)}}class M extends u.G{write(e,t,i,r,s){for(const n of this.vertexBufferLayout.fields.keys()){const o=i.attributes.get(n);if(o)if(n===c.T.PERSPECTIVEDIVIDE){(0,d.hu)(1===o.size);const e=r.getField(n,a.ly);e&&(0,m.XW)(o,e,s)}else(0,m.i9)(n,o,e,t,r,s)}}}class H extends o.Mt{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=s.Vr.None,this.hasOccludees=!1,this.opacity=1,this.textureId=null,this.initTextureTransparent=!0,this.perspectiveInterpolation=!1}}},67581:(e,t,i)=>{i.d(t,{Z:()=>g});var a=i(27366),r=i(7138),s=i(91505),n=i(79056),o=i(32718),l=i(92026),h=i(67426),d=i(49861),c=(i(93169),i(84936),i(69912)),u=i(46634);let p=class extends((0,n.IG)((0,h.v)(s.Z.EventedMixin(r.Z)))){constructor(e){super(e),this._updatingHandles=new u.R,this.layer=null,this.parent=null}initialize(){this.when().catch((e=>{if("layerview:create-error"!==e.name){const t=this.layer&&this.layer.id||"no id",i=this.layer?.title||"no title";o.Z.getLogger(this).error("#resolve()",`Failed to resolve layer view (layer title: '${i}', id: '${t}')`,e)}}))}destroy(){this._updatingHandles=(0,l.SC)(this._updatingHandles)}get fullOpacity(){return(this.layer?.opacity??1)*(this.parent?.fullOpacity??1)}get suspended(){return!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){return!this.suspended&&!0===this.layer?.legendEnabled}get updating(){return!(!this._updatingHandles?.updating&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get visible(){return!0===this.layer?.visible}set visible(e){this._overrideIfSome("visible",e)}canResume(){return this.visible&&this.layer?.loaded&&!this.parent?.suspended&&this.view?.ready||!1}getSuspendInfo(){const e=this.parent?.suspended?this.parent.suspendInfo:{};return this.view?.ready||(e.viewNotReady=!0),this.layer&&this.layer.loaded||(e.layerNotLoaded=!0),this.visible||(e.layerInvisible=!0),e}isUpdating(){return!1}};(0,a._)([(0,d.Cb)()],p.prototype,"fullOpacity",null),(0,a._)([(0,d.Cb)()],p.prototype,"layer",void 0),(0,a._)([(0,d.Cb)()],p.prototype,"parent",void 0),(0,a._)([(0,d.Cb)({readOnly:!0})],p.prototype,"suspended",null),(0,a._)([(0,d.Cb)({readOnly:!0})],p.prototype,"suspendInfo",null),(0,a._)([(0,d.Cb)({readOnly:!0})],p.prototype,"legendEnabled",null),(0,a._)([(0,d.Cb)({type:Boolean,readOnly:!0})],p.prototype,"updating",null),(0,a._)([(0,d.Cb)({readOnly:!0})],p.prototype,"updatingProgress",null),(0,a._)([(0,d.Cb)()],p.prototype,"visible",null),(0,a._)([(0,d.Cb)()],p.prototype,"view",void 0),p=(0,a._)([(0,c.j)("esri.views.layers.LayerView")],p);const g=p},13107:(e,t,i)=>{i.d(t,{Z:()=>l});var a=i(27366),r=i(32718),s=i(66978),n=i(94172),o=(i(93169),i(84936),i(10064),i(69912));const l=e=>{let t=class extends e{initialize(){this.addHandles((0,n.on)((()=>this.layer),"refresh",(e=>{this.doRefresh(e.dataChanged).catch((e=>{(0,s.D_)(e)||r.Z.getLogger(this).error(e)}))})),"RefreshableLayerView")}};return t=(0,a._)([(0,o.j)("esri.layers.mixins.RefreshableLayerView")],t),t}}}]);
//# sourceMappingURL=69229.fe978ec8.chunk.js.map